ANSI-C/cC++ Compiler for HC08 V-5.0.32 Build 9279, Oct  7 2009

    1:  /*
    2:  ** ###################################################################
    3:  **     This code is generated by the Device Initialization Tool.
    4:  **     It is overwritten during code generation.
    5:  **     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
    6:  **     OR EXPLICITLY MARKED SECTIONS
    7:  **
    8:  **     Project   : mc9s08dz60
    9:  **     Processor : MC9S08DZ60MLH
   10:  **     Version   : Component 01.075, Driver 01.06, CPU db: 3.00.021
   11:  **     Datasheet : MC9S08DZ60 Rev. 3 10/2007
   12:  **     Date/Time : 2015/6/3, 14:17
   13:  **     Abstract  :
   14:  **         This module contains device initialization code 
   15:  **         for selected on-chip peripherals.
   16:  **     Contents  :
   17:  **         Function "MCU_init" initializes selected peripherals
   18:  **
   19:  **     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
   20:  **     
   21:  **     http      : www.freescale.com
   22:  **     mail      : support@freescale.com
   23:  ** ###################################################################
   24:  */
   25:  
   26:  /* MODULE MCUinit */
   27:  
   28:  #include <MC9S08DZ60.h>                /* I/O map for MC9S08DZ60MLH */
   29:  #include "MCUinit.h"
   30:  
   31:  /* User declarations and definitions */
   32:  /*   Code, declarations and definitions here will be preserved during code generation */
   33:  /* End of user declarations and definitions */
   34:  
   35:  
   36:  /*
   37:  ** ===================================================================
   38:  **     Method      :  MCU_init (component MC9S08DZ60_64)
   39:  **
   40:  **     Description :
   41:  **         Device initialization code for selected peripherals.
   42:  ** ===================================================================
   43:  */
   44:  void MCU_init(void)
   45:  {

Function: MCU_init
Source  : C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\Sources\MCUinit.c
Options : -AddIncl../preinc.h -Cs08 -D__NO_FLOAT__ -Env"GENPATH=C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\bin;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\device\src;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\lib;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\src;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\06 Platform;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\04 Modules;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\Sources;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\07 Application;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\05 Devices;C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\device\include;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\device\asm_include;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\HC08c\include" -Env"LIBPATH=D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\device\include;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\hc08c\device\asm_include;D:\Program Files\Freescale\CodeWarrior for Microcontrollers V6.3\lib\HC08c\include" -Env"OBJPATH=C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\bin" -Env"TEXTPATH=C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\bin" -Lasm=%n.lst -Ms -ObjN="C:\Users\Administrator\Desktop\新建文件夹 (2)\奥泰10V3T\02 CodeWarrior\mc9s08dz60_Data\Standard\ObjectCode\MCUinit.c.o" -WmsgSd1106

   46:    /* ### MC9S08DZ60_64 "Cpu" init code ... */
   47:    /*  PE initialization code after reset */
   48:  
   49:    /* Common initialization of the write once registers */
   50:    /* SOPT1: COPT=3,STOPE=0,SCI2PS=0,IICPS=0 */
   51:    SOPT1 = 0xC0;                                      
  0000 a6c0     [2]             LDA   #-64
  0002 c70000   [4]             STA   _SOPT1
   52:    /* SOPT2: COPCLKS=0,COPW=0,ADHTS=0,MCSEL=0 */
   53:    SOPT2 = 0x00;                                      
  0005 4f       [1]             CLRA  
  0006 c70000   [4]             STA   _SOPT2
   54:    /* SPMSC1: LVWF=0,LVWACK=0,LVWIE=1,LVDRE=0,LVDSE=1,LVDE=1,BGBE=0 */
   55:    SPMSC1 = 0x2C;                                      
  0009 a62c     [2]             LDA   #44
  000b c70000   [4]             STA   _SPMSC1
   56:    /* SPMSC2: LVDV=1,LVWV=1,PPDF=0,PPDACK=0,PPDC=0 */
   57:    SPMSC2 = 0x30;                                      
  000e a630     [2]             LDA   #48
  0010 c70000   [4]             STA   _SPMSC2
   58:    /*  System clock initialization */
   59:    if (*(unsigned char*far)0xFFAF != 0xFF) { /* Test if the device trim value is stored on the specified address */
  0013 c6ffaf   [4]             LDA   65455
  0016 41ff0a   [4]             CBEQA #-1,L23 ;abs = 0023
   60:      MCGTRM = *(unsigned char*far)0xFFAF; /* Initialize MCGTRM register from a non volatile memory */
  0019 c6ffaf   [4]             LDA   65455
  001c b700     [3]             STA   _MCGTRM
   61:      MCGSC = *(unsigned char*far)0xFFAE; /* Initialize MCGSC register from a non volatile memory */
  001e c6ffae   [4]             LDA   65454
  0021 b700     [3]             STA   _MCGSC
  0023          L23:    
   62:    }
   63:    /* MCGC2: BDIV=0,RANGE=1,HGO=1,LP=0,EREFS=1,ERCLKEN=1,EREFSTEN=0 */
   64:    MCGC2 = 0x36;                        /* Set MCGC2 register */
  0023 6e3600   [4]             MOV   #54,_MCGC2
   65:    /* MCGC1: CLKS=2,RDIV=7,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
   66:    MCGC1 = 0xB8;                        /* Set MCGC1 register */
  0026 6eb800   [4]             MOV   #-72,_MCGC1
   67:    while(!MCGSC_OSCINIT) {              /* Wait until external reference is stable */
  0029 2003     [3]             BRA   L2E ;abs = 002e
  002b          L2B:    
  002b cd0184   [6]             JSR   L184 ;abs = 0184
  002e          L2E:    
  002e 020005   [5]             BRSET 1,_MCGSC,L36 ;abs = 0036
  0031 20f8     [3]             BRA   L2B ;abs = 002b
  0033          L33:    
  0033 cd0184   [6]             JSR   L184 ;abs = 0184
  0036          L36:    
   68:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   69:     SRS = 0xAA;
   70:    }
   71:    while(MCGSC_IREFST) {                /* Wait until external reference is selected */
  0036 090005   [5]             BRCLR 4,_MCGSC,L3E ;abs = 003e
  0039 20f8     [3]             BRA   L33 ;abs = 0033
  003b          L3B:    
  003b cd0184   [6]             JSR   L184 ;abs = 0184
  003e          L3E:    
   72:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   73:     SRS = 0xAA;
   74:    }
   75:    while((MCGSC & 0x0C) != 0x08) {      /* Wait until external clock is selected as a bus clock reference */
  003e b600     [3]             LDA   _MCGSC
  0040 a40c     [2]             AND   #12
  0042 a108     [2]             CMP   #8
  0044 26f5     [3]             BNE   L3B ;abs = 003b
   76:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   77:     SRS = 0xAA;
   78:    }
   79:    /* MCGC2: BDIV=0,RANGE=1,HGO=1,LP=1,EREFS=1,ERCLKEN=1,EREFSTEN=0 */
   80:    MCGC2 = 0x3E;                        /* Set MCGC2 register */
  0046 6e3e00   [4]             MOV   #62,_MCGC2
   81:    /* MCGC1: CLKS=2,RDIV=2,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
   82:    MCGC1 = 0x90;                        /* Set MCGC1 register */
  0049 6e9000   [4]             MOV   #-112,_MCGC1
   83:    /* MCGC3: LOLIE=0,PLLS=1,CME=0,VDIV=4 */
   84:    MCGC3 = 0x44;                        /* Set MCGC3 register */
  004c 6e4400   [4]             MOV   #68,_MCGC3
   85:    /* MCGC2: LP=0 */
   86:    MCGC2 &= (unsigned char)~0x08;                     
  004f 1700     [5]             BCLR  3,_MCGC2
   87:    while(!MCGSC_PLLST) {                /* Wait until PLL is selected */
  0051 2003     [3]             BRA   L56 ;abs = 0056
  0053          L53:    
  0053 cd0184   [6]             JSR   L184 ;abs = 0184
  0056          L56:    
  0056 0a0005   [5]             BRSET 5,_MCGSC,L5E ;abs = 005e
  0059 20f8     [3]             BRA   L53 ;abs = 0053
  005b          L5B:    
  005b cd0184   [6]             JSR   L184 ;abs = 0184
  005e          L5E:    
   88:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   89:     SRS = 0xAA;
   90:    }
   91:    while(!MCGSC_LOCK) {                 /* Wait until PLL is locked */
  005e 0d00fa   [5]             BRCLR 6,_MCGSC,L5B ;abs = 005b
   92:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   93:     SRS = 0xAA;
   94:    }
   95:    /* MCGC1: CLKS=0,RDIV=2,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
   96:    MCGC1 = 0x10;                        /* Set MCGC1 register */
  0061 6e1000   [4]             MOV   #16,_MCGC1
   97:    while((MCGSC & 0x0C) != 0x0C) {      /* Wait until PLL clock is selected as a bus clock reference */
  0064 2003     [3]             BRA   L69 ;abs = 0069
  0066          L66:    
  0066 cd0184   [6]             JSR   L184 ;abs = 0184
  0069          L69:    
  0069 b600     [3]             LDA   _MCGSC
  006b a40c     [2]             AND   #12
  006d a10c     [2]             CMP   #12
  006f 26f5     [3]             BNE   L66 ;abs = 0066
   98:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
   99:     SRS = 0xAA;
  100:    }
  101:    
  102:    /* Common initialization of the CPU registers */
  103:    /* PTASE: PTASE7=0,PTASE6=0,PTASE5=0,PTASE4=0,PTASE3=0,PTASE2=0,PTASE1=0,PTASE0=0 */
  104:    PTASE = 0x00;                                      
  0071 4f       [1]             CLRA  
  0072 c70000   [4]             STA   _PTASE
  105:    /* PTBSE: PTBSE7=0,PTBSE6=0,PTBSE5=0,PTBSE4=0,PTBSE3=0,PTBSE2=0,PTBSE1=0,PTBSE0=0 */
  106:    PTBSE = 0x00;                                      
  0075 c70000   [4]             STA   _PTBSE
  107:    /* PTCSE: PTCSE7=0,PTCSE6=0,PTCSE5=0,PTCSE4=0,PTCSE3=0,PTCSE2=0,PTCSE1=0,PTCSE0=0 */
  108:    PTCSE = 0x00;                                      
  0078 c70000   [4]             STA   _PTCSE
  109:    /* PTDSE: PTDSE7=0,PTDSE6=0,PTDSE5=0,PTDSE4=0,PTDSE3=0,PTDSE2=0,PTDSE1=0,PTDSE0=0 */
  110:    PTDSE = 0x00;                                      
  007b c70000   [4]             STA   _PTDSE
  111:    /* PTESE: PTESE7=0,PTESE6=0,PTESE5=0,PTESE4=0,PTESE3=0,PTESE2=0,PTESE0=0 */
  112:    PTESE &= (unsigned char)~0xFD;                     
  007e 450000   [3]             LDHX  @_PTESE
  0081 f6       [3]             LDA   ,X
  0082 a402     [2]             AND   #2
  0084 f7       [2]             STA   ,X
  113:    /* PTFSE: PTFSE7=0,PTFSE6=0,PTFSE5=0,PTFSE4=0,PTFSE3=0,PTFSE2=0,PTFSE1=0,PTFSE0=0 */
  114:    PTFSE = 0x00;                                      
  0085 4f       [1]             CLRA  
  0086 c70000   [4]             STA   _PTFSE
  115:    /* PTGSE: PTGSE5=0,PTGSE4=0,PTGSE3=0,PTGSE2=0,PTGSE1=0,PTGSE0=0 */
  116:    PTGSE &= (unsigned char)~0x3F;                     
  0089 450000   [3]             LDHX  @_PTGSE
  008c f6       [3]             LDA   ,X
  008d a4c0     [2]             AND   #-64
  008f f7       [2]             STA   ,X
  117:    /* PTADS: PTADS7=0,PTADS6=0,PTADS5=0,PTADS4=0,PTADS3=0,PTADS2=0,PTADS1=0,PTADS0=0 */
  118:    PTADS = 0x00;                                      
  0090 4f       [1]             CLRA  
  0091 c70000   [4]             STA   _PTADS
  119:    /* PTBDS: PTBDS7=0,PTBDS6=0,PTBDS5=0,PTBDS4=0,PTBDS3=0,PTBDS2=0,PTBDS1=0,PTBDS0=0 */
  120:    PTBDS = 0x00;                                      
  0094 c70000   [4]             STA   _PTBDS
  121:    /* PTCDS: PTCDS7=0,PTCDS6=0,PTCDS5=0,PTCDS4=0,PTCDS3=0,PTCDS2=0,PTCDS1=0,PTCDS0=0 */
  122:    PTCDS = 0x00;                                      
  0097 c70000   [4]             STA   _PTCDS
  123:    /* PTDDS: PTDDS7=0,PTDDS6=0,PTDDS5=0,PTDDS4=0,PTDDS3=0,PTDDS2=0,PTDDS1=0,PTDDS0=0 */
  124:    PTDDS = 0x00;                                      
  009a c70000   [4]             STA   _PTDDS
  125:    /* PTEDS: PTEDS7=0,PTEDS6=0,PTEDS5=0,PTEDS4=0,PTEDS3=0,PTEDS2=0,PTEDS1=0,PTEDS0=0 */
  126:    PTEDS = 0x00;                                      
  009d c70000   [4]             STA   _PTEDS
  127:    /* PTFDS: PTFDS7=0,PTFDS6=0,PTFDS5=0,PTFDS4=0,PTFDS3=0,PTFDS2=0,PTFDS1=0,PTFDS0=0 */
  128:    PTFDS = 0x00;                                      
  00a0 c70000   [4]             STA   _PTFDS
  129:    /* PTGDS: PTGDS5=0,PTGDS4=0,PTGDS3=0,PTGDS2=0,PTGDS1=0,PTGDS0=0 */
  130:    PTGDS = 0x00;                                      
  00a3 c70000   [4]             STA   _PTGDS
  131:    /* ### Init_GPIO init code */
  132:    /* PTDD: PTDD4=0,PTDD3=0,PTDD2=0 */
  133:    PTDD &= (unsigned char)~0x1C;                     
  00a6 b600     [3]             LDA   _PTDD
  00a8 a4e3     [2]             AND   #-29
  00aa b700     [3]             STA   _PTDD
  134:    /* PTDPE: PTDPE4=0,PTDPE3=0,PTDPE2=0 */
  135:    PTDPE &= (unsigned char)~0x1C;                     
  00ac 450000   [3]             LDHX  @_PTDPE
  00af f6       [3]             LDA   ,X
  00b0 a4e3     [2]             AND   #-29
  00b2 f7       [2]             STA   ,X
  136:    /* PTDDD: PTDDD4=1,PTDDD3=1,PTDDD2=1 */
  137:    PTDDD |= (unsigned char)0x1C;                      
  00b3 b600     [3]             LDA   _PTDDD
  00b5 aa1c     [2]             ORA   #28
  00b7 b700     [3]             STA   _PTDDD
  00b9 cd0184   [6]             JSR   L184 ;abs = 0184
  138:    /* ### Init_COP init code */
  139:    SRS = 0x55;                          /* Clear WatchDog counter - first part */
  140:    SRS = 0xAA;                          /* Clear WatchDog counter - second part */
  141:    /* ### Init_RTC init code */
  142:    /* RTCMOD: RTCMOD=0x4F */
  143:    RTCMOD = 0x4F;                       /* Set modulo register */
  00bc 6e4f00   [4]             MOV   #79,_RTCMOD
  144:    /* RTCSC: RTIF=1,RTCLKS=1,RTIE=1,RTCPS=8 */
  145:    RTCSC = 0xB8;                        /* Configure RTC */
  00bf 6eb800   [4]             MOV   #-72,_RTCSC
  146:    /* ### Init_SCI init code */
  147:    /* SCI1C2: TIE=0,TCIE=0,RIE=0,ILIE=0,TE=0,RE=0,RWU=0,SBK=0 */
  148:    SCI1C2 = 0x00;                       /* Disable the SCI1 module */
  00c2 3f00     [5]             CLR   _SCI1C2
  149:    (void)(SCI1S1 == 0);                 /* Dummy read of the SCI1S1 register to clear flags */
  00c4 b600     [3]             LDA   _SCI1S1
  150:    (void)(SCI1D == 0);                  /* Dummy read of the SCI1D register to clear flags */
  00c6 b600     [3]             LDA   _SCI1D
  151:    /* SCI1S2: LBKDIF=1,RXEDGIF=1,RXINV=0,RWUID=0,BRK13=0,LBKDE=0,RAF=0 */
  152:    SCI1S2 = 0xC0;                                      
  00c8 6ec000   [4]             MOV   #-64,_SCI1S2
  153:    /* SCI1BDH: LBKDIE=0,RXEDGIE=0,SBR12=0,SBR11=0,SBR10=0,SBR9=0,SBR8=0 */
  154:    SCI1BDH = 0x00;                                      
  00cb 3f00     [5]             CLR   _SCI1BD
  155:    /* SCI1BDL: SBR7=0,SBR6=0,SBR5=0,SBR4=1,SBR3=1,SBR2=0,SBR1=1,SBR0=0 */
  156:    SCI1BDL = 0x1A;                                      
  00cd 6e1a01   [4]             MOV   #26,_SCI1BD:1
  157:    /* SCI1C1: LOOPS=0,SCISWAI=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
  158:    SCI1C1 = 0x00;                                      
  00d0 3f00     [5]             CLR   _SCI1C1
  159:    /* SCI1C3: R8=0,T8=0,TXDIR=1,TXINV=0,ORIE=0,NEIE=0,FEIE=0,PEIE=0 */
  160:    SCI1C3 = 0x20;                                      
  00d2 6e2000   [4]             MOV   #32,_SCI1C3
  161:    /* SCI1C2: TIE=0,TCIE=0,RIE=0,ILIE=0,TE=1,RE=0,RWU=0,SBK=0 */
  162:    SCI1C2 = 0x08;                                      
  00d5 6e0800   [4]             MOV   #8,_SCI1C2
  163:    /* ### Init_SPI init code */
  164:    /* SPIC1: SPIE=0,SPE=0,SPTIE=0,MSTR=0,CPOL=0,CPHA=0,SSOE=0,LSBFE=0 */
  165:    SPIC1 = 0x00;                        /* The SPRF interrupt flag is cleared when the SPI module is disabled. */
  00d8 3f00     [5]             CLR   _SPIC1
  166:    /* SPIC2: MODFEN=0,BIDIROE=0,SPISWAI=0,SPC0=0 */
  167:    SPIC2 = 0x00;                                      
  00da 3f00     [5]             CLR   _SPIC2
  168:    /* SPIBR: SPPR2=0,SPPR1=1,SPPR0=1,SPR2=0,SPR1=1,SPR0=1 */
  169:    SPIBR = 0x33;                                      
  00dc 6e3300   [4]             MOV   #51,_SPIBR
  170:    (void)(SPIS == 0);                   /* Dummy read of the SPIS registr to clear the MODF flag */
  00df b600     [3]             LDA   _SPIS
  171:    /* SPIC1: SPIE=0,SPE=1,SPTIE=0,MSTR=1,CPOL=1,CPHA=1,SSOE=0,LSBFE=0 */
  172:    SPIC1 = 0x5C;                                      
  00e1 6e5c00   [4]             MOV   #92,_SPIC1
  173:    /* ### Init_IIC init code */
  174:    /* IICC2: GCAEN=0,ADEXT=0,AD10=0,AD9=0,AD8=0 */
  175:    IICC2 = 0x00;                                      
  00e4 3f00     [5]             CLR   _IICC2
  176:    /* IICA: AD7=0,AD6=0,AD5=0,AD4=0,AD3=0,AD2=0,AD1=0 */
  177:    IICA = 0x00;                                      
  00e6 3f00     [5]             CLR   _IICA
  178:    /* IICF: MULT1=1,MULT0=0,ICR5=0,ICR4=0,ICR3=0,ICR2=1,ICR1=1,ICR0=1 */
  179:    IICF = 0x87;                                      
  00e8 6e8700   [4]             MOV   #-121,_IICF
  180:    /* IICS: TCF=1,IAAS=0,BUSY=0,ARBL=1,SRW=0,IICIF=1,RXAK=0 */
  181:    IICS = 0x92;                         /* Clear the interrupt flags */
  00eb 6e9200   [4]             MOV   #-110,_IICS
  182:    /* IICC1: IICEN=1 */
  183:    IICC1 |= (unsigned char)0x80;                      
  00ee 1e00     [5]             BSET  7,_IICC1
  184:    /* IICC1: IICEN=1,IICIE=0,MST=0,TX=1,TXAK=0,RSTA=0 */
  185:    IICC1 = 0x90;                                      
  00f0 6e9000   [4]             MOV   #-112,_IICC1
  186:    /* ### Init_MSCAN init code */
  187:    /* CANCTL0: INITRQ=1 */
  188:    CANCTL0 |= (unsigned char)0x01;                      
  00f3 450000   [3]             LDHX  @_CANCTL0
  00f6 f6       [3]             LDA   ,X
  00f7 aa01     [2]             ORA   #1
  00f9 f7       [2]             STA   ,X
  189:    while(!CANCTL1_INITAK) {             /* Wait for init acknowledge */
  00fa 2003     [3]             BRA   LFF ;abs = 00ff
  00fc          LFC:    
  00fc cd0184   [6]             JSR   L184 ;abs = 0184
  00ff          LFF:    
  00ff c60000   [4]             LDA   _CANCTL1
  0102 a501     [2]             BIT   #1
  0104 27f6     [3]             BEQ   LFC ;abs = 00fc
  190:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
  191:     SRS = 0xAA;
  192:    }
  193:    /* CANCTL1: CANE=1,CLKSRC=0,LOOPB=0,LISTEN=0,BORM=0,WUPM=0,SLPAK=0,INITAK=1 */
  194:    CANCTL1 = 0x81;                                      
  0106 a681     [2]             LDA   #-127
  0108 c70000   [4]             STA   _CANCTL1
  195:    /* CANBTR1: SAMP=1,TSEG22=0,TSEG21=1,TSEG20=1,TSEG13=1,TSEG12=0,TSEG11=1,TSEG10=0 */
  196:    CANBTR1 = 0xBA;                                      
  010b a6ba     [2]             LDA   #-70
  010d c70000   [4]             STA   _CANBTR1
  197:    /* CANBTR0: SJW1=0,SJW0=1,BRP5=0,BRP4=0,BRP3=0,BRP2=0,BRP1=0,BRP0=1 */
  198:    CANBTR0 = 0x41;                                      
  0110 a641     [2]             LDA   #65
  0112 c70000   [4]             STA   _CANBTR0
  199:    /* CANIDAC: IDAM1=0,IDAM0=0,IDHIT2=0,IDHIT1=0,IDHIT0=0 */
  200:    CANIDAC = 0x00;                                      
  0115 4f       [1]             CLRA  
  0116 c70000   [4]             STA   _CANIDAC
  201:    /* CANIDAR0: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  202:    CANIDAR0 = 0x00;                                      
  0119 c70000   [4]             STA   _CANIDAR0
  203:    /* CANIDAR1: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  204:    CANIDAR1 = 0x00;                                      
  011c c70000   [4]             STA   _CANIDAR1
  205:    /* CANIDAR2: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  206:    CANIDAR2 = 0x00;                                      
  011f c70000   [4]             STA   _CANIDAR2
  207:    /* CANIDAR3: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  208:    CANIDAR3 = 0x00;                                      
  0122 c70000   [4]             STA   _CANIDAR3
  209:    /* CANIDAR4: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  210:    CANIDAR4 = 0x00;                                      
  0125 c70000   [4]             STA   _CANIDAR4
  211:    /* CANIDAR5: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  212:    CANIDAR5 = 0x00;                                      
  0128 c70000   [4]             STA   _CANIDAR5
  213:    /* CANIDAR6: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  214:    CANIDAR6 = 0x00;                                      
  012b c70000   [4]             STA   _CANIDAR6
  215:    /* CANIDAR7: AC7=0,AC6=0,AC5=0,AC4=0,AC3=0,AC2=0,AC1=0,AC0=0 */
  216:    CANIDAR7 = 0x00;                                      
  012e c70000   [4]             STA   _CANIDAR7
  217:    /* CANIDMR0: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  218:    CANIDMR0 = 0x00;                                      
  0131 c70000   [4]             STA   _CANIDMR0
  219:    /* CANIDMR1: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  220:    CANIDMR1 = 0x00;                                      
  0134 c70000   [4]             STA   _CANIDMR1
  221:    /* CANIDMR2: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  222:    CANIDMR2 = 0x00;                                      
  0137 c70000   [4]             STA   _CANIDMR2
  223:    /* CANIDMR3: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  224:    CANIDMR3 = 0x00;                                      
  013a c70000   [4]             STA   _CANIDMR3
  225:    /* CANIDMR4: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  226:    CANIDMR4 = 0x00;                                      
  013d c70000   [4]             STA   _CANIDMR4
  227:    /* CANIDMR5: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  228:    CANIDMR5 = 0x00;                                      
  0140 c70000   [4]             STA   _CANIDMR5
  229:    /* CANIDMR6: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  230:    CANIDMR6 = 0x00;                                      
  0143 c70000   [4]             STA   _CANIDMR6
  231:    /* CANIDMR7: AM7=0,AM6=0,AM5=0,AM4=0,AM3=0,AM2=0,AM1=0,AM0=0 */
  232:    CANIDMR7 = 0x00;                                      
  0146 c70000   [4]             STA   _CANIDMR7
  233:    /* CANCTL0: INITRQ=0 */
  234:    CANCTL0 &= (unsigned char)~0x01;                     
  0149 450000   [3]             LDHX  @_CANCTL0
  014c f6       [3]             LDA   ,X
  014d a4fe     [2]             AND   #-2
  014f f7       [2]             STA   ,X
  235:    while(CANCTL1_INITAK) {              /* Wait for init exit */
  0150 65       [3]             SKIP2 L153 ;abs = 0153
  0151          L151:   
  0151 ad31     [5]             BSR   L184 ;abs = 0184
  0153          L153:   
  0153 c60000   [4]             LDA   _CANCTL1
  0156 a501     [2]             BIT   #1
  0158 26f7     [3]             BNE   L151 ;abs = 0151
  236:     SRS = 0x55;                         /* Reset watchdog counter write 55, AA */
  237:     SRS = 0xAA;
  238:    }
  239:    /* CANCTL0: RXFRM=0,RXACT=0,CSWAI=0,SYNCH=0,TIME=0,WUPE=0,SLPRQ=0,INITRQ=0 */
  240:    CANCTL0 = 0x00;                                      
  015a 4f       [1]             CLRA  
  015b c70000   [4]             STA   _CANCTL0
  241:    /* CANRIER: WUPIE=0,CSCIE=0,RSTATE1=0,RSTATE0=0,TSTATE1=0,TSTATE0=0,OVRIE=0,RXFIE=0 */
  242:    CANRIER = 0x00;                                      
  015e c70000   [4]             STA   _CANRIER
  243:    /* CANTIER: TXEIE2=0,TXEIE1=0,TXEIE0=0 */
  244:    CANTIER = 0x00;                                      
  0161 c70000   [4]             STA   _CANTIER
  245:    /* ### Init_ADC init code */
  246:    /* SOPT2: ADHTS=0 */
  247:    SOPT2 &= (unsigned char)~0x10;       /* Select the RTC as the source of internal HW trigger */
  0164 450000   [3]             LDHX  @_SOPT2
  0167 f6       [3]             LDA   ,X
  0168 a4ef     [2]             AND   #-17
  016a f7       [2]             STA   ,X
  248:    /* ADCCFG: ADLPC=0,ADIV1=1,ADIV0=0,ADLSMP=0,MODE1=0,MODE0=1,ADICLK1=0,ADICLK0=1 */
  249:    ADCCFG = 0x45;                                      
  016b 6e4500   [4]             MOV   #69,_ADCCFG
  250:    /* ADCCV: ADCV11=0,ADCV10=0,ADCV9=0,ADCV8=0,ADCV7=0,ADCV6=0,ADCV5=0,ADCV4=0,ADCV3=0,ADCV2=0,ADCV1=0,ADCV0=0 */
  251:    ADCCV = 0x00U;                            
  016e 5f       [1]             CLRX  
  016f 8c       [1]             CLRH  
  0170 3500     [5]             STHX  _ADCCV
  252:    /* ADCSC2: ADACT=0,ADTRG=0,ACFE=0,ACFGT=0 */
  253:    ADCSC2 = 0x00;                                      
  0172 3f00     [5]             CLR   _ADCSC2
  254:    /* ADCSC1: COCO=0,AIEN=0,ADCO=1,ADCH4=1,ADCH3=1,ADCH2=1,ADCH1=1,ADCH0=1 */
  255:    ADCSC1 = 0x3F;                                      
  0174 6e3f00   [4]             MOV   #63,_ADCSC1
  256:    /* ### Init_GPIO init code */
  257:    /* PTGD: PTGD5=0 */
  258:    PTGD &= (unsigned char)~0x20;                     
  0177 1b00     [5]             BCLR  5,_PTGD
  259:    /* PTGPE: PTGPE5=0 */
  260:    PTGPE &= (unsigned char)~0x20;                     
  0179 450000   [3]             LDHX  @_PTGPE
  017c f6       [3]             LDA   ,X
  017d a4df     [2]             AND   #-33
  017f f7       [2]             STA   ,X
  261:    /* PTGDD: PTGDD5=1 */
  262:    PTGDD |= (unsigned char)0x20;                      
  0180 1a00     [5]             BSET  5,_PTGDD
  263:    /* ### */
  264:    asm CLI;                             /* Enable interrupts */
  0182 9a       [1]             CLI   
  265:  } /*MCU_init*/
  0183 81       [6]             RTS   
  0184          L184:   
  0184 a655     [2]             LDA   #85
  0186 450000   [3]             LDHX  @_SRS
  0189 f7       [2]             STA   ,X
  018a 48       [1]             LSLA  
  018b f7       [2]             STA   ,X
  018c 81       [6]             RTS   
  266:  
  267:  
  268:  /* Initialization of the CPU registers in FLASH */
  269:  
  270:  /* NVPROT: EPS=3,FPS=0x3F */
  271:  const unsigned char NVPROT_INIT @0x0000FFBD = 0xFF;
  272:  
  273:  /* NVOPT: KEYEN=0,FNORED=1,EPGMOD=1,SEC1=1,SEC0=0 */
  274:  const unsigned char NVOPT_INIT @0x0000FFBF = 0x7E;
  275:  
  276:  
  277:  
  278:  
  279:  
  280:  /* END MCUinit */
  281:  
  282:  /*
  283:  ** ###################################################################
  284:  **
  285:  **     This file was created by Processor Expert 3.07 [04.34]
  286:  **     for the Freescale HCS08 series of microcontrollers.
  287:  **
  288:  ** ###################################################################
  289:  */
  290:  
