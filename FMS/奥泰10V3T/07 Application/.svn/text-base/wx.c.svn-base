/**
  ******************************************************************************
  * proj    firmware startup project
  * file    WX.c
  * ver     1.0
  * brief   This is a WX file for all C files.
  ------------------------------------------------------------------------------
  * 2012.02 created by taoyu@bakai.com
  */ 

/* File Id -------------------------------------------------------------------*/
#define _WX_C_  0x72
#define FILE_No _WX_C_

/* Includes ------------------------------------------------------------------*/
#include  "wx.h"  /* mandotary */
#include  "mcu.h"
#include  "vs.h"
#include  "ts.h"
#include  "bal.h"
#include  "cal.h"
#include  "sc.h"
#include  "pi.h"

/* Private Macros & Defines --------------------------------------------------*/

#ifndef   TUNE_WX
#define   TUNE_WX   0
#endif

#if TUNE_WX
#define WX_PRINTF PRINTF
#else
#define WX_PRINTF empty_printf
#endif

/* Private typedefs ----------------------------------------------------------*/

typedef union
{
  volatile unsigned char all;
  struct
  {
    volatile unsigned heater:1;
    volatile unsigned fan:1;
    volatile unsigned bal:1;
    volatile unsigned sync:1;
    volatile unsigned sleep:1;
    volatile unsigned debug:1;
    volatile unsigned :2;
  }
  bit;
}
wx_ctrl_t;

typedef union
{
  volatile unsigned char  all;
  struct
  {
    volatile unsigned :4;
    volatile unsigned heat:1;
    volatile unsigned ext_bal:1;
    volatile unsigned fan:1;
    volatile unsigned int_bal:1;
  }
  bit;
}
wx_status_t;

typedef union
{
  volatile unsigned char  all;
  struct
  {
    volatile unsigned :2;
    volatile unsigned heat:1;
    volatile unsigned fan:1;
    volatile unsigned ts:1;
    volatile unsigned harness:1;
    volatile unsigned bal:1;
    volatile unsigned comm:1;
  }
  bit;
}
wx_errors_t;

typedef struct {

  //  can rx
  unsigned char msg100_lock;
  unsigned char msg100_age;
  can_frame_t msg100;

  //  control
  wx_ctrl_t ctrl;
  wx_status_t status;
  wx_errors_t errors;
  unsigned long balance;

  //  output
  can_frame_t frame;

}wx_t;

/* Private consts ------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/

wx_t  wx;

/* Private function prototypes -----------------------------------------------*/

/* Global consts -------------------------------------------------------------*/

/* Global variables ----------------------------------------------------------*/
//extern unsigned char fanStatusSY;

/* Functions -----------------------------------------------------------------*/

/**
  * bref    WX function
  * param   none
  * retval  none
  */

//void voltSelect(unsigned short cellVolt, unsigned char cellNum);

void wx_init(void)
{

  /* runtime */
  wx.ctrl.all = 0;
  wx.balance = 0x000000;  /* cell 24,23,22,21,20,...3,2,1 */
  
  //fanStatus = 0;    //fan status inital
  gv_sSC.sWX.bFanStatusLow = 0;
  gv_sSC.sWX.bFanStatusHigh = 0; 
  
  //  sync
  dec_tick = 0;
  
  /* lower level */
  (void)can_init();
}

void wx_reset(void)
{
  /* lower level */
  (void)can_reset();
}

void wx_crx_save(can_frame_t * f)
{

  /* msg100 */
  if( f->id==0x100 && wx.msg100_lock==0 ){
    wx.msg100_age = 0;
    wx.msg100 = *f;
  }
      
}



void wx_sync(void)
{

  if( wx.ctrl.bit.sync ){

    /* wait next msg100 or timeout */
    dec_tick = gv_sSC.sWX.bSyncCycle * gv_sSC.sWX.bSyncTmoMul;
    while( wx.msg100_age>0 && dec_tick>0 ) feed_watch_dog();

    /* timeout */
    if( dec_tick==0 ){
      /* clear sync */
      wx.ctrl.bit.sync = 0;
      /* set sync cycle */
      dec_tick = gv_sSC.sWX.bSyncCycle;
    }

  }else{

    /* wait cycle */
    while( dec_tick>0 ) feed_watch_dog();

    /* set sync cycle */
    dec_tick = gv_sSC.sWX.bSyncCycle;

  }

}

unsigned char wx_crx_proc(void)
{

  unsigned char exit = 0;

  /* lock msg in case access from ISR */
  wx.msg100_lock = 1;

  /* new msg */
  if( wx.msg100_age==0 ){
    unsigned char tgt;

    /* match modnum */
    tgt = wx.msg100.data[0];
    if( tgt==0xff || tgt==gv_sSC.sWX.bModNum ){
      /* control bits */
      wx.ctrl.all = wx.msg100.data[1];
      /* bmu sleep */
      if( wx.ctrl.bit.sleep ){
        exit = 1;
        DBG_PRINTF("sleep from 0x100 cmd\r\n");
      }
      /* balance */
      if( wx.ctrl.bit.bal ){
        (void)bal_ena_int(1);
      }else{
        (void)bal_ena_int(0);
      }
    }
  }

  /* age up */
  if( wx.msg100_age<0xFF ) wx.msg100_age ++;

  /* unlock */
  wx.msg100_lock = 0;

  return exit;

}

void wx_ctx(void)
{

#if 0
  /* 110 */
  {
    unsigned long w;
    //  id, dlc
    wx.frame.id = 0x100 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    /* volt count */
    wx.frame.data[0] = 0x80 + gv_sSC.sWX.bVoltCount;
    /* temp count */
    wx.frame.data[1] = 0x80 + gv_sSC.sWX.bTempCount;
    /* vsum */
    w = (cal.vsum+5)/10;  //  10mV/bit
    if( w>0x7FFF ) w = 0x7FFF;
    w |= 0x8000;
    wx.frame.data[2] = (unsigned char)(w>>8);
    wx.frame.data[3] = (unsigned char)w;
    /* soc, soh */
    wx.frame.data[4] = 0;
    wx.frame.data[5] = 0;
    wx.frame.data[6] = 0;
    wx.frame.data[7] = 0;
    /* xmit */
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }
  
  /* 111 */
  {    
    unsigned short h;
    //  id, dlc
    wx.frame.id = 0x101 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    /* lecu temp */
    h = cal.main_temp;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;
    wx.frame.data[0] = (unsigned char)(h>>8);
    wx.frame.data[1] = (unsigned char)h;
    /* status */
    wx.status.bit.ext_bal = bal_get_ext()? 1: 0;
    wx.status.bit.int_bal = bal_get_int()? 1: 0;
    wx.frame.data[2] = wx.status.all;
    /* errors */
    wx.frame.data[3] = wx.errors.all;
    /* reserved */
    wx.frame.data[4] = 0;
    wx.frame.data[5] = 0;
    wx.frame.data[6] = 0;
    wx.frame.data[7] = 0;
    /* xmit */
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }

  /* 112 */
  {
    unsigned char b;
    unsigned short h;
    //  id, dlc
    wx.frame.id = 0x102 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    /* vmax */
    h = cal.vmax;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[0] = (unsigned char)(h>>8);
    wx.frame.data[1] = (unsigned char)h;
    /* imax */
    b = cal.ivmax;
    if( b<0x80 ) b |= 0x80; else b &= 0x7F;
    wx.frame.data[2] = b + 1;
    /* vmin */
    h = cal.vmin;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[3] = (unsigned char)(h>>8);
    wx.frame.data[4] = (unsigned char)h;
    /* imin */
    b = cal.ivmin;
    if( b<0x80 ) b |= 0x80; else b &= 0x7F;
    wx.frame.data[5] = b + 1;
    /* vave */
    h = cal.vave;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[6] = (unsigned char)(h>>8);
    wx.frame.data[7] = (unsigned char)h;
    /* xmit */
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }
  
  /* 113 */
  {
    unsigned char b;
    unsigned short h;
    //  id, dlc
    wx.frame.id = 0x103 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    //  tmax
    h = cal.tmax;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[0] = (unsigned char)(h>>8);
    wx.frame.data[1] = (unsigned char)h;
    //  imax
    b = cal.itmax;
    if( b<0x80 ) b |= 0x80; else b &= 0x7F;  //  change valid bit
    wx.frame.data[2] = b;
    //  tmin
    h = cal.tmin;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[3] = (unsigned char)(h>>8);
    wx.frame.data[4] = (unsigned char)h;
    //  imax
    b = cal.itmin;
    if( b<0x80 ) b |= 0x80; else b &= 0x7F;  //  change valid bit
    wx.frame.data[5] = b;
    //  tave
    h = cal.tave;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[6] = (unsigned char)(h>>8);
    wx.frame.data[7] = (unsigned char)h;
    //  xmit
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }

  /* 114 */
  {
    //  id, dlc 
    wx.frame.id = 0x104 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    //  software version : 2.0
    wx.frame.data[0] = 0x02;
    wx.frame.data[1] = 0x00;
    //  hardware version
    wx.frame.data[2] = 1;
    wx.frame.data[3] = 6;
    //  wx serial number
    wx.frame.data[4] = 0x20+gv_sSC.sWX.bModNum;
    wx.frame.data[5] = 0xFF;
    wx.frame.data[6] = (unsigned char)(gv_sSC.sWX.hGroupNum>>8);
    wx.frame.data[7] = (unsigned char)gv_sSC.sWX.hGroupNum;
    //  send
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }
  
  /* 115~116 */
  if( wx.ctrl.bit.bmu_req ){
    unsigned char g;
    for(g=0;g<2;g++){
      unsigned char i;
      //  id and dlc
      wx.frame.id = 0x105+g+(gv_sSC.sWX.bModNum<<4);
      wx.frame.dlc = 8;
      //  reset temp
      for(i=0;i<8;i++) wx.frame.data[i] = 0;
      //  temp g.0~g.3
      for(i=0;i<4;i++){
        unsigned char si, ii;
        unsigned short temp;
        //  temp remap
        temp = 0x8000;
        ii = gv_sSC.sWX.baTempMap[4*g+i];
        si = ii>>5;
        ii &= 0x1F;
        if( ii<24 ){
          if( si==0 ){  //  temp from original data
            temp = ts_data.temp[ii];
          }else if( si==1 ){  //  temp from list1
            ii = gv_sSC.sTS.baList1[ii];
            if( ii<24 ) temp = ts_data.temp[ii];
          }else if( si==2 ){  //  temp from list2
            ii = gv_sSC.sTS.baList2[ii];
            if( ii<24 ) temp = ts_data.temp[ii];
          }else if( si==3 ){  //  temp from cal
            temp = cal.temp[ii];
          }else if( si==4 ){  //  temp from sorted temp
            temp = cal.temp_sorted[ii];
          }else{  //  temp from ref temp
            temp = gv_sSC.sCal.haTempRef[ii];
          }
        }
        WX_PRINTF("%d:%u,",ii,temp);
        //  set temp
        if( temp<0x8000 ) temp |= 0x8000; else temp &= 0x7FFF;  //  change valid bit
        wx.frame.data[2*i] = (unsigned char)(temp>>8);
        wx.frame.data[2*i+1] = (unsigned char)temp;          
      }
      //  send can
      (void)can_xmit(&wx.frame);
      delay_ms(1);
    }
  }

  /* 117~11C */
  if( wx.ctrl.bit.bmu_req ){
    unsigned char g;
    for(g=0;g<6;g++){
      unsigned char i;
      if( gv_sSC.sWX.bVoltCount <= 4*g ) break;
      //  id and dlc
      wx.frame.id = 0x107+g+(gv_sSC.sWX.bModNum<<4);
      wx.frame.dlc = 8;
      //  reset volt
      for(i=0;i<8;i++) wx.frame.data[i] = 0;
      //  cell g.0~g.3
      for(i=0;i<4;i++){
        unsigned short volt;      
        if( gv_sSC.sWX.bVoltCount <= 4*g+i ) break;
        volt = cal.volt[4*g+i];
        if( volt<0x8000 ) volt |= 0x8000; else volt &= 0x7FFF;  //  change valid bit
        wx.frame.data[2*i] = (unsigned char)(volt>>8);
        wx.frame.data[2*i+1] = (unsigned char)volt;
      }
      //  send
      (void)can_xmit(&wx.frame);
      delay_ms(1);
    }  
  }
#endif

  static unsigned char cnt = 0;

  /* 110 极值信息 @ 200ms */
  /*{
    unsigned char b;
    unsigned short h;
    //  id, dlc
    wx.frame.id = 0x100 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    //  Vmax
    h = cal.vmax;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[0] = (unsigned char)(h>>8);
    wx.frame.data[1] = (unsigned char)h;
    //  Vmin
    h = cal.vmin;
    if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    wx.frame.data[2] = (unsigned char)(h>>8);
    wx.frame.data[3] = (unsigned char)h;
    //  tmax
    h = (cal.tmax + 5) / 10;
    if( h>0xFF ) h = 0xFF;
    wx.frame.data[4] = (unsigned char)h;
    //  tmin
    h = (cal.tmin + 5) / 10;
    if( h>0xFF ) h = 0xFF;
    wx.frame.data[5] = (unsigned char)h;
    // 最大值编号
    b = (unsigned char)(cal.itmax>0x0F? 0xF0: (cal.itmax<<4));
    b |= (cal.ivmax>0x0F? 0x0F: cal.ivmax);
    wx.frame.data[6] = b;
    // 最小值编号
    b = (unsigned char)(cal.itmin>0x0F? 0xF0: (cal.itmin<<4));
    b |= (cal.ivmin>0x0F? 0x0F: cal.ivmin);
    wx.frame.data[7] = b;
    // xmit //
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }*/
  
  /* 110 极值信息 @ 200ms */
  {
    unsigned char b;
    unsigned short h;
    //unsigned char  wOne = 0x01, wTwo = 0x02, wThr = 0x03, normal = 0;
    //  id, dlc
    wx.frame.id = 0x100 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    
    //data[0]
    //  Temp max threshold warning
    h = (cal.tMaxLow + 5) / 10;
    if( h>0xFF ) h = 0xFF;
    if((h >= TEMPMAX1) && (h <= TEMPMAX2))
      wx.frame.data[0] = (WARL1 << 6);
    else if((h > TEMPMAX2) && (h <= TEMPMAX3))
      wx.frame.data[0] = (WARL2 << 6);
    else if(h > TEMPMAX3)
      wx.frame.data[0] = (WARL3 << 6);
    else 
      wx.frame.data[0] = NORMAL;
    //  Temp min threshold warning
    h = (cal.tMinLow + 5) / 10;  
    if( h>0xFF ) h = 0xFF;
    if((h <= TEMPMIN1) && (h >= TEMPMIN2))
      wx.frame.data[0] |= (WARL1 << 4);
    else if((h < TEMPMIN2) && (h >= TEMPMIN3))
      wx.frame.data[0] |= (WARL2 << 4);
    else if(h < TEMPMIN3)
      wx.frame.data[0] |= (WARL3 << 4);
    else 
      wx.frame.data[0] |= NORMAL;
    //  Volt max threshold warning
    h = cal.vMaxLow;
    //if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    if((h >= VOLTMAX1) && (h <= VOLTMAX2)) 
      wx.frame.data[0] |= (WARL1 << 2);
    else if((h > VOLTMAX2) && (h <= VOLTMAX3))
      wx.frame.data[0] |= (WARL2 << 2);
    else if(h > VOLTMAX3)
      wx.frame.data[0] |= (WARL3 << 2);
    else
      wx.frame.data[0] |= NORMAL;
    //  Volt min threshold warning
    h = cal.vMinLow;
    //if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
    if((h <= VOLTMIN1) && (h >= VOLTMIN2)) 
      wx.frame.data[0] |= WARL1;
    else if((h < VOLTMIN2) && (h >= VOLTMIN3))
      wx.frame.data[0] |= WARL2;
    else if(h < VOLTMIN3)
      wx.frame.data[0] |= WARL3;
    else
      wx.frame.data[0] |= NORMAL;
    
    //data[1]
    //Balance status
    if((bal_get_ext() == 1) || (bal_get_int() == 1)) wx.frame.data[1] = (START << 6);
    else wx.frame.data[1] = STOP;
    //Fan status
    if(gv_sSC.sWX.bFanStatusLow == 1) wx.frame.data[1] |= (START << 4);
    if(gv_sSC.sWX.bFanStatusLow == 0) wx.frame.data[1] |= STOP; 
    // Temp difference warning
    h = (cal.tMaxLow + 5) / 10 - (cal.tMinLow + 5) / 10;
    if( h>0xFF ) h = 0xFF;
    if((h >= TEMPDIFF1) && (h <= TEMPDIFF2))
      wx.frame.data[1] |= (WARL1 << 2);
    else if((h > TEMPDIFF2) && (h <= TEMPDIFF3))
      wx.frame.data[1] |= (WARL2 << 2);
    else if(h >TEMPDIFF3)
      wx.frame.data[1] |= (WARL3 << 2);
    else
      wx.frame.data[1] |= NORMAL;
    // Voltage difference warning
    h = cal.vMaxLow - cal.vMinLow;
    if((h >= VOLTDIFF1) && (h <= VOLTDIFF2))
      wx.frame.data[1] |= WARL1;
    else if((h > VOLTDIFF2) && (h <= VOLTDIFF3))
      wx.frame.data[1] |= WARL2;
    else if(h > VOLTDIFF3)
      wx.frame.data[1] |= NORMAL;
    
    if(gv_sSC.sVS.bLtc6802Count == 2) 
    {
      //data[2]
      //  Temp max threshold warning
      h = (cal.tMaxHigh + 5) / 10;
      if( h>0xFF ) h = 0xFF;
      if((h >= TEMPMAX1) && (h <= TEMPMAX2))
        wx.frame.data[2] = (WARL1 << 6);
      else if((h > TEMPMAX2) && (h <= TEMPMAX3))
        wx.frame.data[2] = (WARL2 << 6);
      else if(h > TEMPMAX3)
        wx.frame.data[2] = (WARL3 << 6);
      else 
        wx.frame.data[2] = NORMAL;
      //  Temp min threshold warning
      h = (cal.tMinHigh + 5) / 10;  
      if( h>0xFF ) h = 0xFF;
      if((h <= TEMPMIN1) && (h >= TEMPMIN2))
        wx.frame.data[2] |= (WARL1 << 4);
      else if((h < TEMPMIN2) && (h >= TEMPMIN3))
        wx.frame.data[2] |= (WARL2 << 4);
      else if(h < TEMPMIN3)
        wx.frame.data[2] |= (WARL3 << 4);
      else 
        wx.frame.data[2] |= NORMAL;
      //  Volt max threshold warning
      h = cal.vMaxHigh;
      //if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
      if((h >= VOLTMAX1) && (h <= VOLTMAX2)) 
        wx.frame.data[2] |= (WARL1 << 2);
      else if((h > VOLTMAX2) && (h <= VOLTMAX3))
        wx.frame.data[2] |= (WARL2 << 2);
      else if(h > VOLTMAX3)
        wx.frame.data[2] |= (WARL3 << 2);
      else
        wx.frame.data[2] |= NORMAL;
      //  Volt min threshold warning
      h = cal.vMinHigh;
      //if( h<0x8000 ) h |= 0x8000; else h &= 0x7FFF;  //  change valid bit
      if((h <= VOLTMIN1) && (h >= VOLTMIN2)) 
        wx.frame.data[2] |= WARL1;
      else if((h < VOLTMIN2) && (h >= VOLTMIN3))
        wx.frame.data[2] |= WARL2;
      else if(h < VOLTMIN3)
        wx.frame.data[2] |= WARL3;
      else
        wx.frame.data[2] |= NORMAL;
      
      //data[3]
      //Balance status
      if((bal_get_ext() == 1) || (bal_get_int() == 1)) wx.frame.data[3] = (START << 6);
      else wx.frame.data[3] = STOP;
      //Fan status
      if(gv_sSC.sWX.bFanStatusHigh == 1) wx.frame.data[3] |= (START << 4);
      if(gv_sSC.sWX.bFanStatusHigh == 0) wx.frame.data[3] |= STOP; 
      // Temp difference warning
      h = (cal.tMaxHigh + 5) / 10 - (cal.tMinHigh + 5) / 10;
       //  output for debug
      {
        static can_frame_t f;
        unsigned char i;
        f.id = 0x500+(gv_sSC.sWX.bModNum<<4);
        f.dlc = 8;
        //fb = bal.low_stt;
        
        for(i = 0; i < 6; i++){
          f.data[i] = (unsigned char)((cal.temp[i] + 5) / 10);
        }
        //f.data[0] = (unsigned char)cal.temp[];
        f.data[6] = (unsigned char)((cal.tMaxHigh + 5) / 10);
        f.data[7] = (unsigned char)((cal.tmax + 5) / 10);
        (void)can_xmit(&f);
    //    DBG_PRINTF("bal: %lXh -> %lXh\n", bal.low_req, fb);
      }
      if( h>0xFF ) h = 0xFF;
      if((h >= TEMPDIFF1) && (h <= TEMPDIFF2))
        wx.frame.data[3] |= (WARL1 << 2);
      else if((h > TEMPDIFF2) && (h <= TEMPDIFF3))
        wx.frame.data[3] |= (WARL2 << 2);
      else if(h >TEMPDIFF3)
        wx.frame.data[3] |= (WARL3 << 2);
      else
        wx.frame.data[3] |= NORMAL;
      // Voltage difference warning
      h = cal.vMaxHigh - cal.vMinHigh;
      if((h >= VOLTDIFF1) && (h <= VOLTDIFF2))
        wx.frame.data[3] |= WARL1;
      else if((h > VOLTDIFF2) && (h <= VOLTDIFF3))
        wx.frame.data[3] |= WARL2;
      else if(h > VOLTDIFF3)
        wx.frame.data[3] |= NORMAL;
    } 
    else 
    {
      wx.frame.data[2] = 0x00;
      wx.frame.data[3] = 0x00;
    }
    
    
    // the max voltage of cell's number for cell 1 to 12, the max temp of resistor's number for cell 1 to 12
    b = (unsigned char)(cal.ivMaxLow>(gv_sSC.sWX.bCellCount-1)? 0xF0: (cal.ivMaxLow<<4));
    b |= (cal.itMaxLow>(gv_sSC.sWX.bResistorCount-1)? 0x0F: cal.itMaxLow);
    wx.frame.data[4] = b;
    // the min voltage of cell's number for cell 1 to 12, the min temp of resistor's number for cell 1 to 12
    b = (unsigned char)(cal.ivMinLow>(gv_sSC.sWX.bCellCount-1)? 0xF0: (cal.ivMinLow<<4));
    b |= (cal.itMinLow>(gv_sSC.sWX.bResistorCount-1)? 0x0F: cal.itMinLow);
    wx.frame.data[5] = b;
    
    if(gv_sSC.sVS.bLtc6802Count == 2) 
    {
      // the max voltage of cell's number for cell 12 to 24, the max temp of resistor's number for cell 12 to 24
      b = (unsigned char)(cal.ivMaxHigh>(gv_sSC.sWX.bVoltCount-1)? 0xF0: (cal.ivMaxHigh<<4));
      b |= (cal.itMaxHigh>(gv_sSC.sWX.bTempCount-1)? 0x0F: cal.itMaxHigh);
      wx.frame.data[6] = b; 
      // the min voltage of cell's number for cell 12 to 24, the min temp of resistor's number for cell 12 to 24
      b = (unsigned char)(cal.ivMinHigh>(gv_sSC.sWX.bVoltCount-1)? 0xF0: (cal.ivMinHigh<<4));
      b |= (cal.itMinHigh>(gv_sSC.sWX.bTempCount-1)? 0x0F: cal.itMinHigh);
      wx.frame.data[7] = b;
    } 
    else
    {
       wx.frame.data[6] = 0x00;
       wx.frame.data[7] = 0x00;
    }
    // xmit //
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }

  // 之前200ms
  cnt ++;
  if( cnt<4) return;
  cnt = 0;
  // 之后1s
  
  /* 115 温度1 @ 1s */
  {
    unsigned char b;
    unsigned short h;
    //  id, dlc
    wx.frame.id = 0x105 + (gv_sSC.sWX.bModNum<<4);
    wx.frame.dlc = 8;
    //  T0~5
    for(b=0;b<6;b++)      //6 is the temp resistor number for SY project 
    {
      h = (cal.temp[b] + 5) / 10;
      if( h>0xFF ) h = 0xFF;
      if((gv_sSC.sVS.bLtc6802Count == 1) && (b >= gv_sSC.sWX.bTempCount)) h = 0xFF;
      wx.frame.data[b] = (unsigned char)h; 
    }
    // 子系统编号2
    wx.frame.data[6] = 0x22;
    // 子系统编号1
    wx.frame.data[7] = 0x11;
    /* xmit */
    (void)can_xmit(&wx.frame);
    delay_ms(1);
  }
  
  /* 117~ 电压1 */
  {
    unsigned char g;
    for(g=0;g<6;g++){
      unsigned char i;
      unsigned short volt;
      if( gv_sSC.sWX.bVoltCount <= 4*g ) break;
      //  id and dlc
      wx.frame.id = 0x107+g+(gv_sSC.sWX.bModNum<<4);
      //  reset volt
      for(i=0;i<8;i++) wx.frame.data[i] = 0;
      //  cell g.0~g.3
      for(i=0;i<4;i++)
      {      
        volt = cal.volt[4*g+i];
        if(volt < 0x8000) volt |= 0x8000; else volt &= 0x7FFF;  //  change valid bit
        /*if(((4*g+i) >= 0) && ((4*g+i) <= gv_sSC.sWX.bVoltCount)) 
        {
          if((volt == 0x8000) && ((4*g+i) >= 10 && ((4*g+i) < gv_sSC.sWX.bVoltCount))) 
          {
            volt = 0;
            volt += volt;
            continue;
          }
          else if(((4*g+i) == gv_sSC.sWX.bVoltCount) && (volt == 0)) break; 
          else 
          {
            wx.frame.data[2*i] = (unsigned char)(volt>>8);
            wx.frame.data[2*i+1] = (unsigned char)volt;
          }
        }*/
        if(((4*g+i) > 9) && (volt == 0))
        {
          wx.frame.dlc = 4;
        } 
        else wx.frame.dlc = 8;
        wx.frame.data[2*i] = (unsigned char)(volt>>8);
        wx.frame.data[2*i+1] = (unsigned char)volt;
        
        if( gv_sSC.sWX.bVoltCount <= 4*g+i ) break;
      }
      //  send
      
       
        (void)can_xmit(&wx.frame);
        delay_ms(1);
        if(volt == 0) break;
     
    }
  }

}



